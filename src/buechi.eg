import "prelude.eg"
import "ltl.eg"
import "dictionary.eg"

# LTL formula to graph. 
# 
# Taken from: https://en.wikipedia.org/wiki/Linear_temporal_logic_to_B%C3%BCchi_automaton

# |f       |curr1(f)| next1(f)    | curr2(f)
# |f1 U f2 | {f1}   | { f1 U f2 } | {f2}
# |f1 R f2 | {f2}   | { f1 R f2 } | {f1,f2}
# |f1 ∨ f2 | {f2}   | ∅           | {f1}

namespace Buechi (
    using LTL

    def curr1 =
        [(ltl_until F0 F1) -> {F0}
        |(ltl_release F0 F1) -> {F1}
        |(ltl_or F0 F1) -> {F1}]

    def next1 =
        [(ltl_until F0 F1) -> {ltl_until F0 F1}
        |(ltl_release F0 F1) -> {ltl_release F0 F1}
        |(ltl_or F0 F1) -> {}]

    def curr2 =
        [(ltl_until F0 F1) -> {F1}
        |(ltl_release F0 F1) -> {F0, F1}
        |(ltl_or F0 F1) -> {F0}]
)

# typedefs
#      LTL: LTL formulas
#      LTLSet: Sets of LTL formulas
#      NodeSet: Sets of graph nodes ∪ {init}
#   
#      globals
#          Nodes : set of graph nodes  := ∅
#          Incoming: Nodes → NodeSet := ∅
#          Now    : Nodes → LTLSet := ∅
#          Next   : Nodes → LTLSet := ∅
#   
#       function create_graph(LTL f) {
#           expand({f}, ∅, ∅, {init})
#           return (Nodes, Now, Incoming)
#       }
# 
# function expand(LTLSet curr, LTLSet old, LTLSet next, NodeSet incoming){
#  if curr = ∅ then
#     if ∃q ∈ Nodes: Next(q)=next ∧ Now(q)=old then
#        Incoming(q)  := Incoming(q) ∪ incoming
#     else
#        q  := new_node()
#        Nodes := Nodes ∪ {q}
#        Incoming(q)  := incoming
#        Now(q)  := old
#        Next(q)  := next
#        expand(Next(q), ∅, ∅, {q})
#  else
#     f ∈ curr
#     curr  := curr\{f}
#     old  := old ∪ {f}
#     match f with
#      | true, false, p, or ¬p, where  p ∈ AP  →
#        if f = false ∨ neg(f) ∈ old then
#           skip
#        else
#           expand(curr, old, next, incoming)
#      | f1 ∧ f2 →
#        expand(curr ∪ ({f1,f2}\old), old, next, incoming)
#      | X g →
#        expand(curr, old, next ∪ {g}, incoming)       
#      | f1 ∨ f2, f1 U f2, or f1 R f2 →
#        expand(curr ∪ (curr1(f)\old), old, next ∪ next1(f), incoming)
#        expand(curr ∪ (curr2(f)\old), old, next, incoming)
#  return
# }

namespace Buechi (
    using System
    using LTL

    def empty = Dict::dict

    def get = [D N -> if Dict::has D N then Dict::get D N else none]

    def set = Dict::set

    def find =
        [P {} -> none |P {X|XX} -> if P X then X else find P XX]

    def expand =
        [{} O N I (NODES, IN, NOW, NEXT) ->
            print "expand:\n";
            print "curr: " (List::map LTL::to_text {}) "\nout: " (List::map LTL::to_text O) "\nnext: " (List::map LTL::to_text N) "\nin: " I "\n";
            let P = do Dict::to_list |> List::map [(A, B) -> (A, List::map LTL::to_text B)] in
            print "Nodes: " (NODES) "\nIncoming: " (Dict::to_list IN) "\nNow: " (P NOW) "\nNext: " (P NEXT) "\n";
            [none ->
                let (Q, NODES) = [NN -> let N = List::length NN in (N,{N|NN})] NODES in
                let IN = set IN Q I in
                let NOW = set NOW Q O in
                let NEXT = set NEXT Q N in
                expand (get NEXT Q) {} {} {Q} (NODES, IN, NOW, NEXT)
            |Q ->
                let IN = set IN Q (List::union (get IN Q) I) in
                (NODES, IN, NOW, NEXT)
            ]
            (find [Q -> and (get NEXT Q == N) (get NOW Q == O)] NODES)
        |{F|FF} O N I (NODES, IN, NOW, NEXT) ->
            print "expand:\n";
            print "curr: " (List::map LTL::to_text {F|FF}) "\nout: " (List::map LTL::to_text O) "\nnext: " (List::map LTL::to_text N) "\nin: " I "\n";
            let P = do Dict::to_list |> List::map [(A, B) -> (A, List::map LTL::to_text B)] in
            print "Nodes: " (NODES) "\nIncoming: " (Dict::to_list IN) "\nNow: " (P NOW) "\nNext: " (P NEXT) "\n";
            let O = {F|O} in
            [ ltl_false ->
                (NODES, IN, NOW, NEXT)
            | ltl_true -> 
                if List::elem ltl_false O then (NODES, IN, NOW, NEXT)
                else expand FF O N I (NODES, IN, NOW, NEXT)
            | (ltl_variable S) ->
                if List::elem (ltl_not (ltl_variable S)) O then (NODES, IN, NOW, NEXT)
                else expand FF O N I (NODES, IN, NOW, NEXT)
            | (ltl_not (ltl_variable S)) ->
                if List::elem (ltl_variable S) O then (NODES, IN, NOW, NEXT)
                else expand FF O N I (NODES, IN, NOW, NEXT)
            | (ltl_and F0 F1) ->
                let FF = List::union FF (List::difference {F0,F1} O) in
                expand FF O N I (NODES, IN, NOW, NEXT)
            | (ltl_next F) ->
                let N = List::union {F} N in
                expand FF O N I (NODES, IN, NOW, NEXT)
            | (ltl_or F0 F1) -> 
                    expand (List::union FF (List::difference (curr2 F) O)) O N I
                    (expand (List::union FF (List::difference (curr1 F) O)) O (List::union N (next1 F)) I (NODES, IN, NOW, NEXT))
            | (ltl_until F0 F1) -> 
                    expand (List::union FF (List::difference (curr2 F) O)) O N I
                    (expand (List::union FF (List::difference (curr1 F) O)) O (List::union N (next1 F)) I (NODES, IN, NOW, NEXT))
            | (ltl_release F0 F1) -> 
                    expand (List::union FF (List::difference (curr2 F) O)) O N I
                    (expand (List::union FF (List::difference (curr1 F) O)) O (List::union N (next1 F)) I (NODES, IN, NOW, NEXT))] F ]

    def to_graph =
        [ F ->
            let (NODES, IN, NOW, NEXT) = expand {F} {} {} {0} ({}, empty, empty, empty) in 
                (F, NODES, NOW, IN) ]

)

# Let (Nodes, Now, Incoming) = create_graph(f). An equivalent LGBA to f is A=(Nodes, 2AP, L, Δ, Q0, F), where
# 
# L = { (q,a) | q ∈ Nodes and (Now(q) ∩ AP) ⊆ a ⊆ {p ∈ AP | ¬p ∉ Now(q) } }
# Δ = {(q,q')| q,q' ∈ Nodes and q ∈ Incoming(q') }
# Q0 = { q ∈ Nodes | init ∈ Incoming(q) }
# For each sub-formula g = g1 U g2, let Fg = { q ∈ Nodes | g2 ∈ Now(q) or g ∉ Now(q) }, then F = { Fg | g ∈ cl( f ) }

namespace Buechi (
    using System

    def to_lgba =
        [(F, NODES, NOW, IN) ->
            print "lgba:\n";
            print "form: " (LTL::to_text F) "\n";
            print "ap: " (LTL::ap F) "\n";
            print "nodes: " NODES "\n";
            print "now: " (Dict::to_list NOW) "\n";
            print "incoming " (Dict::to_list IN) "\n";
            none ]
)


using System

def main =
    Lexer::lexify LTL::lexemes "test" """
form0: G foo;
#form1: ~(b /\ (false -> c));
"""
    |> LTL::filter_whitespace
    |> LTL::parse
    |> List::map snd 
    |> List::map LTL::simplify
    |> List::map LTL::to_nnf
    |> List::map Buechi::to_graph
    |> List::map Buechi::to_lgba
#    |> List::map LTL::pretty
#    |> List::map [S -> print S "\n"]; none

