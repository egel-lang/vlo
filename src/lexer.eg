import "prelude.eg"
import "regex.ego"

namespace Position (
    data position

    def to_text = [(position URL X Y) -> System::format "{} {} {}" URL X Y]

    def deltay = [(position URL X Y) DY -> position URL X (Y System::+ DY)]

    def deltax = [(position URL X Y) DX -> position URL (X System::+ DX) Y]

    def delta_len = [POS S -> deltay POS (String::length S)]
)

namespace Lexer (
    using Position
    using System
    using List

    data token, token_class

    def token_class_compile = [(token_class ID REGEX DELTA) -> token_class ID (Regex::compile REGEX) DELTA]

    def match_class = 
        [(token_class C R DELTA) (POS, S) -> 
            Regex::look_match R S
            ||> [ S0 -> (String::split (String::count_char S0) S) ] 
            ||> [ (S0, S1) -> (token C POS S0, (DELTA POS S) S1) ]]

    def try_all = [{} X -> none | {F|FF} X -> let Y = F X in if Y == none then try_all FF X else Y]

    def lexify0 =
        [TT (_, "") -> {} 
        |TT (POS, S) -> 
            [none -> throw (format "lexer error at: {}" (Position::to_text POS))
            |(T,(POS,S)) -> {T| lexify0 TT (POS,S)}] 
                (try_all TT (POS,S))]

    def lexify = 
        [TT URL S -> lexify0 (map token_class_compile TT |> map match_class) (position URL 0 0, S)]

)

